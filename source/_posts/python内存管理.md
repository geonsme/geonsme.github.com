---
title: Python垃圾回收机制
toc: true
date: 2018-10-25
description: Python垃圾回收机制
category: 
 - 后端
tag:
 - python
---

## Python垃圾回收

平时一些平台开发用Python很多，分析Python的内存管理原理可以避免写出内存泄露的代码。在Python中，万物都是对象，垃圾回收机制以引用计数为主，标记-清除和分代回收为辅。

### 引用计数

- Python主要采用的垃圾回收机制是引用计数法，引用计数法在Java和C++中都有用到，是很常用的内存自动回收机制。

- 对象结构体《Python源码剖析》

```python
 typedef struct_object {
 int ob_refcnt;
 struct_typeobject *ob_type;
} PyObject;
```

- 引用计数法原理是每个对象维护一个`ob_refcnt`字段，用来记录当前对象被引用的次数，每当有新的引用指向对象时，`ob_refcnt`字段增加1，每当有引用失效时候，`ob_refcnt`字段减少1，一旦对象的引用计数为0，该对象生命期就结束了，对象所分配的内存空间也被释放。

- 引用计数的优点

1. 操作简单
每个对象都维护自己的计数器，一旦计数器变为0，即被系统回收

2. 实时性
能够及时处理失效的对象所占的内存空间，不用单独对回收时间处理

- 引用计数缺点

1. Python中一切都是对象，运行中维护着庞大的计数器，消耗系统资源

2. 循环引用导致计数器无法归零。测试代码中，list_a和list_b相互引用会导致在del list_a时候，由于list_b对象还在，导致引用计数最小为1，同理，list_b对象引用计数也为1，循环引用导致两个对象生命期不会结束，所占内存无法释放，导致内存泄露。
```python
list_a = []
list_b = []
list_a.append(list_b)
list_b.append(list_a)
del list_a
del list_b
```

## 标记-清除

循环引用导致引用计数的垃圾回收机制出现了很大的弊端，引入了追踪回收（tracing GC）来解决。循环引用的问题根本在于容器对象的使用，比如字典、列表、类、元组。标记清除通过跟踪容器对象，及时发现循环引用位置进行处理。

因此，标记-清除的思路是每个容器对象维护两个额外的指针，用来将容器对象组装成一个链表，两个指针分别指向两个前后两个容器对象，构成一个有向图。

- 标记活动对象

GC会把所有的活动对象打上标记

- 清理非活动对象

没有被标记的对象进行回收

- 查找非活动对象

容器对象之间通过指针连接成有向图，引用关系构成了有向图的边，从根对象出发（root oject），沿着有向边遍历，可达到的对象为活动对象，并一一标记。不可达到的为不活动对象，就会被GC。

![](http://t1.aixinxi.net/o_1crd8rpo716n41eo7q14rbdp4aa.png-w.jpg)

```python
a = [0, 1]
b = [2, 3]
a.append(b)
b.append(a)
del a
del b

```
在执行del a时候，a的引用计数从2减为1，b的引用计数也减为1，标记-清除算法找到a，发现有对b的引用，则将b引用计数减1，因为a直接引用b，找到b，同样对a有一个引用，将a的引用减1，完成ab的引用关系拆减，ab的引用计数降为0，被系统回收。

标记-清除算法有个缺点是清除非活动对象，必须扫描所有的对象，系统开销是比较大的。

## 分代回收

分代回收也是辅助回收技术，类似于阈值回收，即GC的触发机制是达到了GC阈值即开始强制GC，随着Python程序的运行，不断有对象被创建和销毁，如果存在循环引用就会导致创建>>回收，当创建和回收的差值到达了GC阈值，就会触发分代回收。

Python将内存中的对象存活时间分为3个集合，分别为年轻代（0代），中年代（1代），老年代（2代），新创建的对象都会放在年轻代，年轻代达到数量后，强制将能回收的对象回收，不会回收的对象被移动到中年代，最后最不活跃的对象会进入老年代，老年代的对象一般是全局存在的，直到进程退出，生命周期结束。

分代回收很有意思，它将对象标记成3中状态，根据不同状态设定不同的阈值，每一个对象的计数器增加将触发垃圾检查，回收不同生命期的对象，控制不同生命期对象数量。






